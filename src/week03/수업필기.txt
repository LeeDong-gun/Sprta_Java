객체란?
 객체는 세상에 존재하는 물체를 뜻하며 식별이 가능한 것을 의미합니다.
    - 예를 들자면 물리적으로 존재하는 자동차, 도서관, 계산기를 객체라 볼 수 있습니다.
    - 강의, 배달주문, 운동과 같은 개념적인 것 또한 식별이 가능하기 때문에 객차라 볼 수 있습니다.
 자동차를 기반으로 하여 객체에 대해 좀 더 자세하게 살펴보겠습니다.
 객체는 속성과 행위로 구성되어 있습니다.
    - 자동차의 속성과 행위를 표현해 보겠습니다.
        1) 자동차는 회사, 모델, 색상, 가격, 속도 등의 속성을 가질 수 있습니다.
        2) 자동차는 가속, 브레이크, 기어변속, 조명, 경적등의 행위를 가질 수 있습니다.
 JAVA에서는 이러한 속성과 행위를 필드와 메서드로 정의하여 구현할 수 있습니다.
 이처럼 현실 세계에 있는 객체를 소프트웨어의 객체로 설계하는 것을 '객체 모델링' 이라고 부릅니다.

객체 간의 협력
 현실세계에서 사람이라는 객체와 자동차라는 객체는 서로 행위를 통해 상호작용을 하며 협력 할 수 있습니다.
    - 사람이 자동차의 가속 페달을 밟으면 자동차는 이에 반응하여 속도를 올리며 앞으로 이동합니다.
    - 사람이 자동차의 브레이크 페달을 밟으면 자동차는 이에 반응하여 속도를 줄이며 정지합니다.
 그렇다면 소프트웨어의 객체들 끼리는 어떻게 상호 작용을 할 수 있을까요?
    - 바로 행위를 정의하는 Java의 메서드를 통해 이루어집니다.
    - 사람 객체는 자동차 객체가 가지고있는 가속 페달 이라는 메서드 gasPedal(); 를 호출합니다.
        1) 그러면 자동차 객체는 이에 반응하여 속도 속성의 값을 증가 시킵니다.
    - 사람 객체는 자동차 객체가 가지고 있는 브레이크 페달이라는 메서드 brakePedal(); 를 호출합니다.
        1) 그러면 자동차 객체는 이에 반응하여 속도 속성의 값을 갑소 시킵니다.
 또한 소프트웨어의 객체들은 메서드를 통해 데이터를 주고 받을 수도 있습니다.
 사람 객체는 메서드를 호출할 때 괄호() 안에 데이터를 넣어 호출할 수 있는데 이때 이 괄호안에 넣는 데이터를 '파라미터' 혹은
 '매개값' 이라고 표현합니다.
 사람 객체는 gasPedal(50); 이렇게 메서드 괄호 안에 50의 매개값을 넣어 호출합니다.
    - 그러면 자동차 객체는 해당하는 50의 데이터를 전달 받아 자동차 객체의 속서인 속도의 값을 50으로 만듭니다.
    - 또한 자동차 객체는 gasPedal(50); 메서드에서 속도를 받꾸는 작업을 수행한 후 사람 객체에게 실행 결과인 속도의 값을
      받환할 수 있습니다. 이때 반환되는 값을 '리턴값' 이라 표현합니다.

객첵 간의 관계
 현실세계에서의 객체는 수많은 관계를 맺고 살아갑니다.
 예를 들어 위에서 살펴본 것 처럼 사람 객체는 자동차 객체를 사용하는 '사용의 관계'를 맺고 있습니다.
 자동차 객체를 통해서 소프트웨어의 객체 간의 관계에 대해 좀 더 자세하게 살펴보겠습니다.
 일전에 객체지향 프로그래밍은 필요한 부품들을 만들고 하나씩 조립해서 하나의 완성된 프로그램을 만드는 기법이라고 설명 드렸습니다.
 한번 현실세계의 자동차를 생각 해볼까요?
    - 현실세계에서 자동차를 만들기 위해서는 수많은 부품들이 필요합니다.
    - 예를 들어 자동차의 타어어, 차문, 핸들 등이 필요합니다.
 이를 소프트웨어의 객체 간의 관계로 표현해보겠습니다.
    - 사용 관계
        1) 사람 객체는 자동차 객체를 사용합니다.
    - 포함 관계
        2) 타어이 객체, 차문 객체, 핸들 객체는 자동차 객체에 포합되어있습니다.
    - 상속 관계
        1) 만약 공장에 자동차만 생산하는게 아니라 기차도 생산한다고 가졍해보겠습니다.
        2) 자동차와 기차 객체는 하나의 공통된 기계시스템 객체를 토대로 만들어진다고 가정해보겠습니다.
        3) 그렇다면 자동차 객체와 기차 객체는 기계시스템 객체를 상속 받는 상속 관계가 됩니다.

객체지향 프로그래밍의 특징
우리가 객체지향 프로그래밍을 하다보면 필연적으로 만나게 되는 개념이 있습니다.
    - 바로 캡슐화, 상속, 다향성, 추상화입니다.
    - 앞으로 학습하게 되는 내용에 포함되어 있기 때문에 간단하게 학습하고 가겠습니다.
1. 캡슐화
 -캡슐화란 속성(필드)와 행위(메서드)를 하나로 묶어 객체로 만든 후 실제 내부 구현 내용은 외부에서 알 수 없게 감추는 것을 의미합니다.
 -외부 객체에서는 캡슐화 된 객체의 내부 구조를 알 수 없기 때문에 노출시켜 준 필드 혹은 메서드를 통해 접근할 수 있습니다.
 -필드와 메서드를 캡슐화 하여 숨기는 이유는 외부객체에서 해당 필드와 메서드를 잘못 사용하여 객체가 변화하지 않게 하는데 있습니다.
 -Java에서는 캡슐화된 객체의 필드와 메서드를 노출 시킬지 감출 지 결정하기 위해 접근 제어자를 사용합니다.

2. 상속
 - 객체지향 프로그래밍에는 부모 객체와 자식 객체가 존재합니다.
 - 부모객체는 가지고 있는 필드와 메서드를 자식 객체에 물려주어 자식 객체가 이를 사용할 수 있도록 만들 수 있습니다.
 MachineSystem 이라는 객체 안에 Blue Print 라는 메서드가 있는데 이 메서드가 Car(자식 객체)와 Train(자식 객체)에 필요하다면
                            MachineSystem(부모 객체)의 메서드가 수정이되면 자식 개체의 메서드도 변경이 됩니다.
                            - 위와 같은 행위를 상속이라고 할 수 있는데 상속을 하는 이유는 다음과 같습니다.
                               1) 각각의 객체들을 상속 관계로 묶음으로써 객체 간의 구조를 파악하기 쉬워집니다.
    2) 필드와 메서드를 변경하는 경우 부모 객체에 있는 것만 수정하게 되면 자식 객체 전부 반영이 되기 때문에 일관성을 유지하기 좋습니다.
    3) 자식 객체가 부모객체의 필드와 메서드를 물려받아 사용할 수 있기 때문에 코드의 중복이 줄어들며 코드의 재사용성이 증가됩니다.

3. 다형성
 객체가 연산을 수행할 때 하나의 행위에 대해 각 개체가 가지고 있는 고유한 특성에 따라 다른 여러가지 형태로 재구성 되는 것을 의미합니다.
 Car클래스를 토대로 자동차 객체를 만들 때 A자동차 객체와 B자동차 객체의 경적 소리가 다르다면 '경적을 울리다'라는 행위 즉, horn(); 메서드의
 구현을 다르게 재정의 하여 사용할 수 있습니다.

4. 추상화
 객체에서 공통된 부분들을 모아 상위 개념으로 새롭게 선언하는 것을 추상화라고 합니다.
    - 공통적이고 중요한 것들을 모아 객체를 모델링합니다.
    - 현실세게의 여러 종류의 자동차들이 공통적으로 가지고 있는 가속, 브레이크, 속도 와 같은 것들을 모아 자동차라는 객체를 모델링 할 수 있습니다.

객체와 클래스
 우리는 객체를 생성하기 위해서 설계도가 필요합니다.
 현실세계에서는 자동차를 만들기 위해 자동차 설계도를 토대로 자동차를 생산합니다.
 마찬가지로 소프트웨어에서도 객체를 만들기위해서는 설계도에 해당하는 클래스가 필요합니다.
 이때 클래스를 토대로 생성된 객체를 해당 클래스의 '인스턴스'라고 부르며 이 과정을 '인스턴스화'라고 부릅니다.
 동일한 클래스로 여러 개의 인스턴스를 만들 수 있습니다.
 이때 객체와 인스턴스는 거의 비슷한 표현이지만 자세하게 구분해보자면 Car공장(클래스) -> 자동차 객체 1,2,3 (자동차객체) 를 인스턴스라고 하며
 이 과정을 '인스턴스화'라고 한다.
 자동차 클래스를 통해 만들어진 하나의 자동차를 인스턴스라고 부르며 이러한 여러개의 인스턴스들을 크게 통틀어서 자동차 객체라고 표현할수있다.

메서드 오버로딩
 오버로딩은 함수가 하나의 기능만을 구현하는 것이 아니라 하나의 메서드 이름으로 여러 기능을 구현하도록 하는
 Java의 기능입니다.
 즉, 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도, 매개변수의 개수 또는 타입, 순서가
 다르면 동일한 이름을 사용해서 메서드를 정의할 수 있습니다.

오버로딩의 조건
 - 메서드의 이름이 같고, 매개변수의 개수, 타입, 순서가 달라야 합니다!!
 - '응답 값만' 다른 것은 오버로딩을 할 수 없습니다.
 - 접근 제어자만 다른 것도 오버로딩을 할 수 없습니다.
 - 결론, 오버로딩은 매개변수의 차이로만 구현할 수 있습니다!!

오버로딩의 장점
  1. 메서드 이름 하나로 상황에 따른 동작을 개별로 정의할 수 있습니다.
    a. 예를 들면 메세지 출력할 때 쓰는 println() 이 있습니다.
    b. println() 의 매개변수로는 int, double, String, boolean 등 다양하게 넣을 수 있습니다.
  2. 메서드의 이름을 절약할 수 있습니다.
    a. 만약 오버로딩이 안된다면 println() 는 printlnInt(), printlnDouble() 처럼 메서드명이 길어지고 낭비 되었을 것입니다.

기본형 & 참조형 매개변수
  1. 기본형 매개변수
    메서드를 호출할 때 전달할 매개값으로 지정한 값을 메서드의 매개변수에 복사해서 전달합니다.
        1) 매개변수의 타입이 기본형일 때는 값 자체가 복사되어 넘어가기 때문에 매개값으로 지정된 변수의 원본 값이 변경되지 않습니다.
  2. 참조형 매개변수
    메서드를 호출할 때 전달할 매개값으로 지정한 값의 주소를 매개변수에 복사해서 전달합니다.
        1) 매개변수를 참조형으로 선언하면 값이 저장된 곳의 원본 주소를 알 수 있기 때문에 값을 읽어 오는 것은 물론 값을 변경하는 것도 가능합니다.
        2) 메서드의 매개변수 뿐만 아니라 반환타입도 참조형이 될 수 있습니다.
            - 반환타입이 참조형이라는 것은 반환ㅇ하는 값이 타입이 "실제값의 주소"라는 의미입니다.

인스턴스 멤버와 클래스 멤버
 멤버 = 필드 + 메서드
  - 인스턴스 멤버 = 인스턴스 필드 + 인스턴스 메서드
  - 클래스 멤버 = 클래스 필드 + 클래스 메서드
 인스턴스 멤버 & 클래스 멤버
  - 필드와 메서드는 선언하는 방법에 따라서 인스턴스 멤버와 클래스 멤버로 구분할 수 있습니다.
  - 인스턴스 멤버는 객체 생성 후에 사용할 수 있고 클래서 멤버는 객체 생성 없이도 사용할 수 있습니다.

인스턴스 멤버
 지금까지 학습하면서 선언한 필드와 메서드는 전부 인스턴스 멤버였습니다.
  - 인스턴스 멤버는 객체를 생성해야 사용할 수 있다고 했습니다.
  - 또한 객체의 인스턴스 필드는 각각의 인스턴스 마다 고유하게 값을 가질 수 있습니다.
  - 그렇다고 객체가 인스턴스화 할 때마다 객체의 메서드들은 인스턴스에 포함되어 매번 생성이 될까요?
   1) 그렇지 않습니다. 매번 저장한다면 중복저장으로 인해 메모리 효율이 매우 떨어지기 때문에 메서드는 메서드 영역에
      두고서 모든 인스턴스들이 공유해서 사용합니다.
   2) 대신 무조건 객체를 생성 즉, 인스턴스를 통해서만 메서드가 사용될 수 있도록 제한을 걸어둔 것입니다.

클래스 멤버
 클래스는 Java의 클래스 로더에 의해 메서드 영역에 저장되고 사용합니다.
  - 이때 클래스 멤버란 메서드 영역의 클래스와 같은 위치에 고정적으로 위치하고 있는 멤버를 의미합니다.
  - 따라서 클래스 멤버는 객체의 생성 필요없이 바로 사용이 가능합니다.

클래스 멤버 선언
 필드와 메서드를 클래스 멤버로 만들기 위해서는 static키워드를 사용하면 됩니다.
  - 일반적으로 인스턴스마다 모두 가지고 있을 필요없는 공용적인 데이터를 저장하는 필드는 클래스 멤버로 선언하는 것이 좋습니다.
  - 또한 인스턴스 필드를 사용하지 않고 실행되는 메서드가 존재한다면 static 키워드를 사용여 클래스 메서드로 선언하는 것이 좋습니다.

final 필드와 상수
 final은 '최종적' 이라는 의미입니다.
    - final 필드는 초기값이 저장되면 해당값을 프로그램이 실행하는 도중에는 절대로 수정할 수 없습니다.
    - 또한 final 필드는 반드시 초기값을 지정해야 합니다.

상수
 상수의 특징은 값이 반드시 한개이며 불변의 값을 의미합니다.
 따라서 인스턴스마다 상수를 저장할 필요가 없습니다.
 final 앞에 static 키워드를 추가하여 모든 인스턴스가 공유할 수 있는 값이 한개이며 불변인 상수를 선언할 수 있습니다.
 사용방법은 일반적인 클래스 필드와 동일합니다. 다만 수정이 불가능합니다.


생성자 (=> constructor)
  생성자는 객체가 생성될 때 호출되며 객체를 초기화하는 역할을 수행합니다.
  생성자는 반환 타입이 없고 이름은 클래스의 이름과 동일합니다.
  new 연산자에 의해 객체가 생성되면서 생성자가 호출합니다.

기본 생성자
 기본 생성자는 선언할 때 괄호() 안에 아무것도 넣지 않는 생성자를 의미합니다.
    - 모든 클래스는 반드시 생성자가 하나 이상 존재합니다.
    - 만약 클래스에 생성자를 하나도 선언하지 않았다면 컴파일러는 기본 생성자를 바이트코드 파일에 자동으로 추가 시켜줍니다.
      따라서 이러한 경우는 기본 생성자 생략이 가능합니다.
    - 반대로 단 하나라도 생성자가 선언되어있다면 컴파일러는 기본 생성자를 추가하지 않습니다.
    - 컴파일러에 의해 생성되는 기본 생성자는 해당 클래스의 접근 제어자(public,...)를 따릅니다.

필드 초기화와 생성자 오버로딩
  필드 초기화
   생성자는 객체를 초기화하는 역할을 수행합니다.
    1) 객체를 만들때 인스턴스마다 다른 값을 가져야 한다면 생성자를 통해서 필드를 초기화 할 수 있습니다.
        - 예를 들어 만들어지는 자동차 마다 모델, 색상, 가격이 다르다면 생성자를 사용하여 필드의 값을 초기화 하는 것이 좋습니다.
    2) 반대로 인스턴스 마다 동일한 데이터를 가지는 필드는 초기값을 대입하는 것이 좋습니다.
        - 예를 들어 자동차가 만들어질 때마다 기어의 상태를 'P' 로 고정해야 한다면 초기값을 직접 대입하는 것이 좋습니다.

  생성자 오버로딩
   생성자를 통해 필드를 초기화 할 때 오버로딩을 적용할 수 있습니다.
    1) 예를들어 우리가 자동차를 생성할 때 모델, 생삭, 가격이 다른 자동차를 여러대 생성할 수도 있고 색상만 다른 자동차를 여러대
       생성할 수도 있기 때문에 오버로딩을 사용하면 이를 효율적으로 처리할 수 있습니다.
    2) 오버로딩을 할 때 개수, 타입, 순서가 동일한다 매개변수 명만 다르게 하는 경우는 오버로딩 규칙에 위배되기 때문에 오류가 발생합니다.

this 와 this()
this
 this는 객체 즉, 인스턴스 자신을 표현하는 키워드입니다.
  1) 객체 내부 생성자 및 메서드에서 객체 내부 멤버에 접근하기 위해 사용될 수 있습니다.
  2) 객체 내부 멤버에 접근할 때 this 키워드가 필수는 아니지만 상황에 따라 필수가 될 수 있습니다.
    - 만약 생성자를 선언하는데 매개변수명과 객체의 필드명이 동일할 경우 오류가 발생하지는 않지만 생성자
      블록 내부에서 해당 변수들은 객체의 필드가 아닌 가장 가까운 매개변수명을 가리키게 됨으로 자기 자신에게
      값을 대입하는 상황이 되어 버립니다
    - 이럴 경우에 this 키워드를 사용하면 해결할 수 있습니다.
 또한 this는 인스턴스 자신을 뜻하기 때문에 객체의 메서드에서 리턴타입이 인스턴스 자신의 클래스 타입이라면 this
 를 사용하여 인스턴스 자신의 주소를 반환할 수도 있습니다.

this()
 this(...)는 객체 즉, 인스턴스 자신의 생성자를 호출하는 키워드입니다.
  1) 객체 내부 생성자 및 메서드에서 해당 객체의 생성자를 호출하기 위해 사용될 수 있습니다.
  2) 생성자를 통해 객체의 필드를 초기화할 때 중복되는 코드를 줄여줄 수 있습니다.
    - 생성자를 선언한다고 했을 때 코드의 중복이 발생합니다.
    - 이때 this() 키워드를 사용하면 코드의 중복을 제거할 수 있습니다.
  3) this() 키워드를 사용해서 다른 생성자를 호출할 때는 반드시 해당 생성자의 첫 줄에 작성되어야 합니다.
  4) this() 키워드로 다른 생성자 호출 이전에 코드가 존재하면 오류가 발생합니다.

접근 제어자
 제어자는 클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여해 줍니다.
  1) 접근 제어자 : public, protected, default, private
  2) 그 외 제어자 : static, final, abstract
 ! 하나의 대상에 여러 개의 제어자를 조합해서 사용할 수 있으나, 접근 제어자는 단 하나만 사용할 수 있습니다.

접근 제어자
 멤버 또는 클래스에 사용, 외부에서 접근하지 못하도록 제한합니다.
  1) 클래스, 멤버변수, 메서드, 생성자에 사용되고, 지정되어 있지 않다면 default 입니다.
    - public : 접근 제한이 전혀 없습니다.
    - protected : 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근이 가능합니다.
    - default : 같은 패키지 내에서만 접근이 가능합니다.
    - private : 같은 클래시 내에서만 접근이 가능합니다.

사용가능한 접근 제어자
    1) 클래스 : public, default
    2) 메서드 & 멤버변수 : public, protected, default, private
    3) 지역변수 : 없음
접근 제어자를 이요한 캡슐화 (은닉성)
    1) 접근제어자는 클래스 내부에 선언된 데이터를 보호하기 위해서 사용합니다.
    2) 유효한 값을 유지하도록, 함부로 변경하지 못하도록 접근을 제한하는 것이 필요합니다.
생성자의 접근 제어자
    1) 생성자에 접근 제어자를 사용함으로 인스턴스의 생성을 제한할 수 있습니다.
    2) 일반적으로 생성자의 접근 제어자는 클래스의 접근 제어자와 일치합니다.

Getter 와 Setter
 객체의 무결성 즉, 변경이 없는 상태를 유지하기 위해 접근 제어자를 사용합니다.
    1) 이때 외부에서 필드에 직접 접근하는 것을 막기 위해 필드에 private, default 등의 접근 제어자를 사용할 수 있습니다.
    2) 그렇다면 우리는 어떻게 객체의 private 필드를 읽어오거나 저장할 수 있을까요?
    3) 우리는 Getter 와 Setter를 사용하여 이를 해결할 수 있습니다.

Getter
 외부에서 객체의 private 한 필드를 읽을 필요가 있을 때 Getter 메서드를 사용합니다.
 private double speed; // 자동차 속도, Km/h
 private char gear = 'P'; // 기어의 상태, P, R, N, D
 private boolean lights; // 자동차 조명의 상태
    - 자동차 클래스의 필드에 이처럼 private 접근 제어자로 지정한 필드가 있을 때 Getter 메서드를 통해 값을 가져올 수 있습니다.

 public String getModel() {
    return model;
 }
 public String getColor() {
     return Color;
 }
 public String getPrice() {
     return price;
 }
    - 메서드 이름의 규칙은 : get + 필드이름(첫 글자 대문자) 입니다.
    - 사용하는 방법은 인스턴스 메서드 호출과 동일합니다.

Setter
 외부에서 객체의 private 한 필드를 저장/수정할 필요가 있을 때 Setter 메서드를 사용합니다.
  private double speed; // 자동차 속도, Km/h
  private char gear = 'P'; // 기어의 상태, P, R, N, D
  private boolean lights; // 자동차 조명의 상태
    - 자동차 클래스의 필드에 이처럼 private 접근 제어자로 지정한 필드가 있을 때 Setter 메서드를 통해 값을 저장하거나 수정할 수 있습니다.

제어자의 조합
    1) 사용 가능한 제어자
        - 클래스 : public, default, final, abstract
        - 메서드 : public, protected, default, private, final, abstract, static
        - 멤버변수 : public, protected, default, private, final, static
        - 지역변수 : final

상속
1. 클래스간의 관계와 상속
 상속의 사전적 정의는 부모가 자식에게 물려주는 행위를 말합니다.
    1) 객체 지향 프로그램에서도 부모 클래스의 필드와 메서드를 자식 클래스에게 물려줄 수 있습니다.
    2) 상속을 사용하면 적은 양의 코드로 새로운 클래스를 작성할 수도 있고 공통적인 코드를 관리하여 코드의
       추가와 변경이 쉬워질 수도 있습니다.
    3) 이러한 특성 때문에 상속을 사용하면 코드의 중복이 제거되고 재사용성이 크게 증가하여 생산성과
       유지보수성에 매우 유리해 집니다.
상속
 클래스간의 상속은 extends 키워드를 사용하여 정의할 수 있습니다.
    public class 자식클래스 extends 부모클래스 {

    }
    1) 상속의 키워드는 extends 입니다. 눈치채셨나요?
        - 우리는 상속의 개념을 확장의 개념으로 이해해야합니다.
        - 자칫하여 부모 클래스, 자식 클래스라는 용어에 현혹되어 '부모가 자식보다 큰 사람이니까 부모
          클래스도 마찬가지로 자식 클래스 보다 큰 범위겠지?' 라고 생각하는 순간 헷갈리기 시작합니다...
    2) 헷갈리기 시작할 때마다 아래 3문장을 떠올리세요!
        - 부모 클래스에 새로운 필드와 메서드가 추가되면 자식 클래스는 이를 상속받아 사용할 수 있다.
        - 자식 클래스에 새로운 필드와 메서드가 추가되어도 부모 클래스는 어떠한 영향도 받지 않는다.
        - 따라서 자식 클래스의 멤버 개수는 부모 클래스보다 항상 같거나 많다.

클래스간의 관계
 클래스간의 관계를 분석하여 관계설정을 해줄 수 잇습니다.
    - 상속관계 : is - a ("~은 ~(이)다")
    - 포함관계 : has -a ("~은~(을)를 가지고있다")
  1) 상속관계는 위에서 예제로 살펴본 스포츠카와 자동차도 있지만 한가지 더 예를 들자면 고래와 포유류가 있습니다.
  2) 위 공식에 대입해보겠습니다.
    - 상속관계 : 고래는 포유류다
    - 포함관계 : 고래는 포유류를 가지고있다..?
  3) 어떤가요? 이제 고래 클래스와 포유류 클래스의 관계를 어떻게 설정하면 좋을지 파악이 되시나요?
  4) 상속관계는 위에서 연습해 봤으니 포함관계도 학습해 보겠습니다.
포함관계
 포함관계는 우리가 일전에 봤던 자동차와 타이어, 차문, 핸들 과의 관계라고 볼 수 있습니다.
    1) 한번 위 공식에 대입해 보겠습니다.
    2) 자동차는 타이어를 가지고 있다.
    3) 자동차는 차문을 가지고 있다.
    4) 자동차는 핸들을 가지고 있다.

단일 상속과 다중 상속
 Java는 다중상속을 허용하지 않습니다.
  1) 다중상속을 허용하면 복잡한 소프트웨어의 기능을 구현할 때 여러개의 클래스를 상속받아 쉽게 구현할 수 있다는 장점이 있는데
     ...왜? 허용하지 않을까요?
  2) 왜냐하면 다중상속을 허용하면 클래스간의 관계가 복잡해지는 문제가 생기기 때문입니다.
  3) 만약 자식 클래스에서 상속받은 서로 다른 부모 클래스들이 같은 이름의 멤버를 가지고 있다면?
  4) 자식 클래스에서는 이 멤버를 구별할 수 있는 방법이 없다는 문제가 생깁니다.

final 클래스와 final 메서드
 final 키워드를 클래스와 메서드에 선언하면 어떻게 될까요?
    public final class Car {}
    ...
    public class SportsCar extends Car {} // 오류가 발생합니다.
 클래스에 final 키워드를 지정하여 선언하면 최종적인 클래스가 됨으로 더 이상 상속할 수 없는 클래스가 됩니다.
    public class Car {
        public final void horn () {
            System.out.println("빵빵");
        }
    }
    ...
    public class SportsCar extends Car {
        public void horn() {  // 오류가 발생합니다.
            super.horn();
        }
    }
 메서드에 final 키워드를 지정하여 선언하면 최종적인 메서드가 됨으로 더 이상 오버라이딩 할 수 없는 메서드가 됩니다.

Object
 Object 는 말그대로 "객체"를 의미하는 단어이며 보통, Object 클래스를 의미합니다.
    1) Object 클래스는 Java 내 모든 클래스들의 최상위 부모 클래스 입니다.
    2) 따라서, 모든 클래스는 Object의 메서드를 사용할 수 있습니다.
    3) 또한 부모 클래스가 없는 자식 클래스는 컴파일러에 의해 자동으로 Object 클래스를 상속받게 됩니다.

 Object 클래스의 메서드를 몇가지 소개해 드리겠습니다.
    1) Object clone() : 해당 객체의 복제본을 생성하여 반환함.
    2) boolean equals(Object object) : 해당 객체와 전달받은 객체가 같은지 여부를 반환함.
    3) class getClass() : 해당 객체의 클래스 타입을 반환함.
    4) int hashCode() : 자바에서 객체를 식별하는 정수값인 해시 코드를 반환함.
    5) String toString() : 해당 객체의 정보를 문자열로 반환함 & Object 클래스에서 클래스이름 @해쉬코드값 리턴함.
    ...

오버라이딩
 부모 클래스로부터 상속받은 메서드의 내용을 재정의 하는 것을 오버라이딩이라고 합니다.
  - 부모 클래스의 메서드를 그대로 사용 가능하지만 자식 클래스의 상황에 맞게 변경을 해야하는 경우 오버라이딩
    을 이용합니다.
  - 오버라이딩을 하기 위해서는 아래 조건들을 만족해야 합니다.
    1) 선언부가 부모 클래스의 메서드와 일치해야 합니다.
    2) 접금 제어자를 부모 클래스의 메서드 보다 좁은 범위로 변경할 수 없습니다.
    3) 예외는 부모 클래스의 메서드 보다 많이 선언할 수 없습니다.

super 와 super()
 super
  super는 부모 클래스의 멤버를 참조할 수 있는 키워드입니다.
    - 객체 내부 생성자 및 메서드에서 부모 클래스의 멤버에 접근하기 위해 사용될 수 있습니다.
    - 자식 클래스 내부에서 선언한 멤버와 부모 클래스에서 상속받은 멤버와 이름이 같을 경우 이를 구분하기 위해 사용합니다.
    - 부모 클래스
        // 부모 클래스 Car
        String model; // 자동차모델
        String color; // 자동차 색상
        double price; // 자동차 가격
    - 자식 클래스
        // 자식 클래스 SportsCar
        String model = "Ferrari"; // 자동차 모델
        String color = "Red"; // 자동차 색상
        double price = 300000000; // 자동차 가격
    - 자식 클래스의 메서드
        public void setCarInfo(String model, String color, double price) {
            super.model = model; // model은 부모 필드에 set
            super.color = color; // color는 부모 필드에 set
            this.price = price; // price는 자식 필드에 set
        }
     1) 자식 클래스의 메서드를 호출하면 super 키워드로 접근한 부모 클래스의 model, color 필드에 매개변수의 값이 저장됩니다.
     2) this 키워드로 접근한 자식 클래스의 price 필드에는 매개변수의 값이 저장됩니다.

다형성
 1. 참조변수의 타입 변환
  자동 타입 변환
   부모타입 변수 = 자식타입객체; 는 자동으로 부모타입으로 변환이 일어납니다.
    자식 객체는 부모 객체의 멤버를 상속받기 때문에 부모와 동일하게 취급될 수 있습니다.
     - 예를 들어 포유류 클래스를 상속받은 고래 클래스가 있다면 포유류 고래 = 고래객체; 가 성립될 수 있습니다.
     - 왜냐하면 고래 객체는 포유류의 특징인 모유수유 행위를 가지고 있기 때문입니다.
     - 다만 주의할 점은 부모타입 변수로 자식객체의 멤버에 접근할 때는 부모 클래스에 선언된 즉, 상속받은
       멤버만 접근할 수 있습니다.
  강제 타입 변환
   부모타입객체는 자식타입 변수로 자동으로 타입변환이 되지 않습니다.
   이럴때는 (자식타입) 즉, 타입변환 연산자를 사용하여 강제로 자식타입으로 변환할 수 있습니다.
   다만 무조건 강제 타입 변환을 할 수 있는 것은 아닙니다.
    1) 자식 타입 객체가 부모 타입으로 자동 타입 변환된 후 다시 자식 타입으로 변환 될 때만 강제 타입 변환이 가능합니다.
    2) 부모 타입 변수로는 자식 타입 객체의 고유한 멤버를 사용할 수 없기 때문에 사용이 필요한 경우가 생겼을 때 강제 타입 변환을 사용합니다.

다형성이란?
 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미합니다.
  1) 예를 들어 자동차의 핸들을 교체하면 핸들링이 부드러워지고 바퀴를 교체하면 승차감이 좋아집니다.
  2) 소프트웨어 또한 구성하고 있는 객체를 바꿨을 때 소프트웨어의 실행 성능 및 결과물이 다르게 나올 수 있습니다.
  3) 일전에 배운 참조변수 타입변환을 활용해서 다형성을 구현할 수 있습니다.
   Tire tire = new HankookTire("HANKOOK");
   Tire tire = new KiaTire("KIA");
  4) 부모타이어 변수 = 자식타이어객체; 를 선언하여 자동 타입변환된 변수를 사용하여 각각의 자식타이어 객체에 재정의된 메서드를
     통해 다양한 승차감을 가진 자동차를 생성할 수 있습니다.

instanceof
 다형성 기능으로 인해 해당 클래스 객체의 원래 클래스명을 체크하는것이 필요한데 이때 사용할 수 있는 명령어가
 instance of 입니다.
    1) 이 명령어를 통해서 해당 객체가 내가 의동하는 클래스의 객체인지 확인할 수 있습니다.
    2) {대상 객체} instance of {클래스 이름} 와 같은 형태로 사용하면 응답값은 boolean 입니다.